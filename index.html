<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SATB Chord Progression Analyzer</title>

    <!-- External Libraries - Loaded locally for reliability -->
    <script src="vexflow.min.js"></script>
    <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
    <link rel="stylesheet" href="styles.css">
    
    <style>
        body {
            font-family: 'Georgia', serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #faf9f6;
        }
        
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 10px;
        }
        
        .key-selection-section {
            margin: 30px 0;
            padding: 25px;
            border: 3px solid #9b59b6;
            border-radius: 10px;
            background-color: #f8f9fa;
        }
        
        .key-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .key-controls label {
            font-size: 18px;
            font-weight: bold;
            color: #2c3e50;
        }
        
        .key-dropdown {
            padding: 12px;
            font-size: 16px;
            border: 2px solid #9b59b6;
            border-radius: 5px;
            background-color: white;
            color: #2c3e50;
            font-weight: bold;
            min-width: 150px;
        }
        
        .key-btn {
            background-color: #9b59b6;
            color: white;
        }
        
        .key-btn:hover {
            background-color: #8e44ad;
        }
        
        .key-info {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background-color: #ecf0f1;
            border-radius: 5px;
            font-size: 18px;
            font-weight: bold;
            color: #2c3e50;
        }
        
        .bass-line-section {
            margin: 30px 0;
            padding: 25px;
            border: 3px solid #3498db;
            border-radius: 10px;
            background-color: #f8f9fa;
        }
        
        .bass-input-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .note-input {
            padding: 12px;
            font-size: 18px;
            border: 2px solid #3498db;
            border-radius: 5px;
            width: 80px;
            text-align: center;
            font-weight: bold;
        }
        
        .control-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
        }
        
        .add-btn {
            background-color: #3498db;
            color: white;
        }
        
        .add-btn:hover {
            background-color: #2980b9;
        }
        
        .clear-btn {
            background-color: #e74c3c;
            color: white;
        }
        
        .clear-btn:hover {
            background-color: #c0392b;
        }
        
        .delete-btn {
            background-color: #7f8c8d;
            color: white;
        }

        .delete-btn:hover {
            background-color: #6c7a7d;
        }
        
        .analyze-btn {
            background-color: #f39c12;
            color: white;
            font-size: 18px;
            padding: 15px 30px;
        }
        
        .analyze-btn:hover {
            background-color: #e67e22;
        }
        
        .bass-line-display {
            margin: 25px 0;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            border: 2px dashed #bdc3c7;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .bass-note-display {
            background-color: #e8f4f8;
            border: 2px solid #3498db;
            border-radius: 8px;
            padding: 15px;
            position: relative;
            min-width: 60px;
            text-align: center;
        }
        
        .bass-note-display .measure-num {
            position: absolute;
            top: -8px;
            left: 5px;
            background-color: #3498db;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .bass-note-display .note-name {
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
            margin-top: 8px;
        }
        
        .progression-suggestions {
            margin: 30px 0;
            padding: 25px;
            border: 3px solid #e74c3c;
            border-radius: 10px;
            background-color: #fdf2f2;
            display: none;
        }
        
        .suggestion-item {
            margin: 20px 0;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            border-left: 5px solid #e74c3c;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .suggestion-item:hover {
            background-color: #f8f9fa;
            transform: translateX(5px);
        }
        
        .suggestion-item.selected {
            background-color: #d5f4e6;
            border-left-color: #27ae60;
        }

        .scoring-guide {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
        }

        .scoring-guide h4 {
            margin-top: 0;
            color: #495057;
            border-bottom: 2px solid #dee2e6;
            padding-bottom: 10px;
        }

        .score-ranges {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }

        .score-range {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            border-radius: 6px;
            border-left: 4px solid;
        }

        .score-range.excellent {
            background-color: #d4edda;
            border-left-color: #28a745;
        }

        .score-range.very-good {
            background-color: #d1ecf1;
            border-left-color: #17a2b8;
        }

        .score-range.good {
            background-color: #fff3cd;
            border-left-color: #ffc107;
        }

        .score-range.fair {
            background-color: #f8d7da;
            border-left-color: #dc3545;
        }

        .score-label {
            font-weight: bold;
            min-width: 130px;
        }

        .score-description {
            font-size: 14px;
            color: #6c757d;
            text-align: right;
        }

        .scoring-factors {
            background-color: white;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #e9ecef;
        }

        .scoring-factors ul {
            margin: 8px 0;
            padding-left: 20px;
        }

        .scoring-factors li {
            margin: 4px 0;
            font-size: 14px;
        }
        
        .progression-title {
            font-size: 18px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .progression-style {
            font-size: 14px;
            font-weight: bold;
            color: #8e44ad;
            margin: 5px 0;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .roman-numerals {
            font-family: 'Courier New', monospace;
            font-size: 20px;
            font-weight: bold;
            color: #e74c3c;
            margin: 10px 0;
        }
        
        .progression-description {
            font-size: 14px;
            color: #666;
            font-style: italic;
            margin-top: 8px;
        }
        
        .progression-analysis {
            font-size: 14px;
            color: #555;
            margin-top: 10px;
            line-height: 1.4;
        }
        
        .function-breakdown {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .function-tag {
            background-color: #ecf0f1;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            color: #2c3e50;
        }
        
        .satb-output {
            margin: 30px 0;
            padding: 25px;
            border: 3px solid #27ae60;
            border-radius: 10px;
            background-color: #f1f8e9;
            display: none;
        }
        
        .audio-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 20px 0;
            padding: 15px;
            background-color: #ecf0f1;
            border-radius: 8px;
            flex-wrap: wrap;
        }
        
        .play-btn {
            background-color: #27ae60;
            color: white;
        }
        
        .play-btn:hover {
            background-color: #229954;
        }
        
        .stop-btn {
            background-color: #e74c3c;
            color: white;
        }
        
        .stop-btn:hover {
            background-color: #c0392b;
        }
        
        .audio-controls label {
            font-weight: bold;
            color: #2c3e50;
        }
        
        #tempoSlider {
            width: 150px;
            margin: 0 10px;
        }
        
        #tempoValue {
            color: #27ae60;
            font-weight: bold;
        }
        
        /* SATB Validation Results Styling */
        .validation-results {
            background-color: #f8f9fa;
            padding: 25px;
            border-radius: 8px;
            margin: 25px 0;
            border: 2px solid #e9ecef;
        }
        
        .validation-score {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .validation-score h3 {
            color: #2c3e50;
            margin: 0;
        }
        
        #validationScore {
            color: #27ae60;
            font-weight: bold;
            font-size: 1.2em;
        }
        
        .validation-content {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }
        
        .errors-section, .warnings-section, .suggestions-section {
            background-color: white;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #bdc3c7;
        }
        
        .errors-section {
            border-left-color: #e74c3c;
        }
        
        .warnings-section {
            border-left-color: #f39c12;
        }
        
        .suggestions-section {
            border-left-color: #3498db;
        }
        
        .compromises-section {
            border-left-color: #9b59b6;
        }
        
        .errors-section h4 {
            color: #e74c3c;
            margin-top: 0;
        }
        
        .warnings-section h4 {
            color: #f39c12;
            margin-top: 0;
        }
        
        .suggestions-section h4 {
            color: #3498db;
            margin-top: 0;
        }
        
        .compromises-section h4 {
            color: #9b59b6;
            margin-top: 0;
        }
        
        .compromise-explanation {
            font-style: italic;
            color: #7f8c8d;
            margin-bottom: 15px;
        }
        
        .validation-item {
            background-color: #f8f9fa;
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            border-left: 3px solid #bdc3c7;
        }
        
        .error-item {
            border-left-color: #e74c3c;
            background-color: #ffeaea;
        }
        
        .warning-item {
            border-left-color: #f39c12;
            background-color: #fff3cd;
        }
        
        .suggestion-item {
            border-left-color: #3498db;
            background-color: #e3f2fd;
        }
        
        .compromise-item {
            border-left-color: #9b59b6;
            background-color: #f3e5f5;
        }
        
        .validation-item-header {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .validation-item-location {
            color: #7f8c8d;
            font-size: 0.9em;
            font-style: italic;
        }
        
        /* Score Breakdown Styling */
        .score-breakdown-btn {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 10px;
            transition: background-color 0.3s;
        }
        
        .score-breakdown-btn:hover {
            background-color: #2980b9;
        }
        
        .score-breakdown {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 6px;
            margin-top: 15px;
            border: 1px solid #e9ecef;
        }
        
        .breakdown-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .breakdown-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background-color: white;
            border-radius: 4px;
            border: 1px solid #dee2e6;
        }
        
        .breakdown-label {
            font-weight: 600;
            color: #495057;
        }
        
        .breakdown-value {
            font-weight: bold;
            color: #28a745;
        }
        
        .breakdown-value.negative {
            color: #dc3545;
        }
        
        .score-criteria {
            border-top: 1px solid #dee2e6;
            padding-top: 15px;
        }
        
        .criteria-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-top: 10px;
        }
        
        .criteria-section {
            background-color: white;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
        }
        
        .criteria-section strong {
            color: #495057;
            display: block;
            margin-bottom: 8px;
        }
        
        .criteria-section ul {
            margin: 0;
            padding-left: 20px;
        }
        
        .criteria-section li {
            margin-bottom: 4px;
            font-size: 13px;
            color: #6c757d;
        }
        
        .selected-progression {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
        }
        
        .voice-parts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }
        
        .voice-part {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
        
        .voice-part h3 {
            margin-top: 0;
            color: #2c3e50;
        }
        
        .voice-notes {
            font-family: 'Courier New', monospace;
            font-size: 16px;
            line-height: 1.6;
        }

        #bassStaff, #satbStaff {
            border: 1px solid #ccc;
            padding: 20px;
            background-color: white;
            border-radius: 5px;
            overflow-x: auto;
            overflow-y: visible;
            min-height: 300px;
            width: 100%;
            box-sizing: border-box;
        }
        
        #satbStaff svg {
            max-width: none; /* Allow SVG to be wider than container */
            height: auto;
        }

        #loadingIndicator {
            display: none;
            text-align: center;
            font-size: 18px;
            color: #e67e22;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>SATB Progression Analyzer</h1>
        
        <div class="key-selection-section">
            <h2>Select Key</h2>
            <div class="key-controls">
                <label for="keySelect">Key:</label>
                <select id="keySelect" class="key-dropdown">
                    <option value="C major">C Major</option>
                    <option value="G major">G Major</option>
                    <option value="D major">D Major</option>
                    <option value="A major">A Major</option>
                    <option value="E major">E Major</option>
                    <option value="F major">F Major</option>
                    <option value="Bb major">B‚ô≠ Major</option>
                    <option value="Eb major">E‚ô≠ Major</option>
                    <option value="A minor">A Minor</option>
                    <option value="E minor">E Minor</option>
                    <option value="B minor">B Minor</option>
                    <option value="D minor">D Minor</option>
                    <option value="G minor">G Minor</option>
                    <option value="C minor">C Minor</option>
                    <option value="F minor">F Minor</option>
                </select>
                <button onclick="updateKeyDisplay()" class="control-btn key-btn">Update Key</button>
        </div>
        </div>
        
        <div class="key-info" id="keyInfo">Currently in: C Major</div>

        <div class="bass-line-section">
            <h2>1. Input Your Bass Line</h2>
            <div class="bass-input-controls">
                <input type="text" id="bassNoteInput" class="note-input" placeholder="e.g., C4">
                <button onclick="addBassNote()" class="control-btn add-btn">Add Note</button>
                <button onclick="deleteLastNote()" class="control-btn delete-btn">Delete Last</button>
                <button onclick="clearBassLine()" class="control-btn clear-btn">Clear All</button>
            </div>
            <div id="bassStaff"></div>
            </div>
            
        <div class="bass-line-section">
            <h2>2. Analyze & Get Chord Progressions</h2>
            <button onclick="analyzeBassLine()" class="control-btn analyze-btn">Analyze Bass Line</button>
            <div id="loadingIndicator">Analyzing... please wait.</div>
        </div>
        
        <div class="progression-suggestions" id="progressionSuggestions">
            <h2>3. Choose a Progression</h2>
            <div id="suggestionsList"></div>
            
            <!-- Scoring Reference Guide -->
            <div class="scoring-guide" id="scoringGuide" style="display: none;">
                <h4>üìä Scoring Reference Guide</h4>
                <div class="score-ranges">
                    <div class="score-range excellent">
                        <span class="score-label">Excellent (120+)</span>
                        <span class="score-description">Strong voice leading, classical progressions, perfect cadences</span>
                    </div>
                    <div class="score-range very-good">
                        <span class="score-label">Very Good (100-119)</span>
                        <span class="score-description">Good harmonic flow, minor voice leading issues</span>
                    </div>
                    <div class="score-range good">
                        <span class="score-label">Good (80-99)</span>
                        <span class="score-description">Functional harmony, some awkward progressions</span>
                    </div>
                    <div class="score-range fair">
                        <span class="score-label">Fair (Below 80)</span>
                        <span class="score-description">Basic functionality, may have unusual or weak progressions</span>
                    </div>
                </div>
                <div class="scoring-factors">
                    <p><strong>Factors that improve scores:</strong></p>
                    <ul>
                        <li>Strong progressions (V‚ÜíI, IV‚ÜíV, ii‚ÜíV)</li>
                        <li>Proper cadences (authentic, plagal)</li>
                        <li>Circle of fifths progressions</li>
                        <li>Classical harmonic rhythm</li>
                    </ul>
                    <p><strong>Factors that lower scores:</strong></p>
                    <ul>
                        <li>Weak progressions (I‚Üíii, vi‚Üíiii)</li>
                        <li>Unusual chord sequences</li>
                        <li>Lack of tonal direction</li>
                        <li>Too many inversions</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="satb-output" id="satbOutput">
            <h2>4. View & Hear SATB Result</h2>
            <div class="audio-controls">
                <button onclick="playCurrentSATB()" class="control-btn play-btn" id="playBtn">‚ñ∂ Play SATB</button>
                <button onclick="stopCurrentSATB()" class="control-btn stop-btn" id="stopBtn">‚èπ Stop</button>
                <label for="tempoSlider">Tempo: <span id="tempoValue">120</span> BPM</label>
                <input type="range" id="tempoSlider" min="60" max="200" value="120" oninput="updateTempo(this.value)">
            </div>
            <div id="satbStaff"></div>
            
            <div class="export-controls">
                <h4>Export Options</h4>
                <button onclick="exportToPDF()" class="control-btn" style="background: #e74c3c;">üìÑ Export PDF</button>
                <button onclick="exportToMusicXML()" class="control-btn" style="background: #27ae60;">üéµ Export MusicXML</button>
            </div>
            </div>
            
        <!-- SATB Rule Validation Results -->
        <div class="validation-results" id="validationResults" style="display: none;">
            <h2>5. SATB Rule Analysis</h2>
            <div class="validation-score">
                <h3>Overall Score: <span id="validationScore">--</span>/100</h3>
                <button id="scoreBreakdownBtn" class="score-breakdown-btn" onclick="toggleScoreBreakdown()" style="display: none;">
                    üìä Show Score Breakdown
                </button>
                <div id="scoreBreakdown" class="score-breakdown" style="display: none;">
                    <h4>Score Calculation Details:</h4>
                    <div class="breakdown-grid">
                        <div class="breakdown-item">
                            <span class="breakdown-label">Base Score:</span>
                            <span id="baseScore" class="breakdown-value">100</span>
                </div>
                        <div class="breakdown-item">
                            <span class="breakdown-label">Errors (-20 each):</span>
                            <span id="errorDeductions" class="breakdown-value">-0</span>
                </div>
                        <div class="breakdown-item">
                            <span class="breakdown-label">Warnings (-5 each):</span>
                            <span id="warningDeductions" class="breakdown-value">-0</span>
                </div>
                        <div class="breakdown-item">
                            <span class="breakdown-label">Voice Leading Quality:</span>
                            <span id="voiceLeadingScore" class="breakdown-value">+0</span>
                </div>
                        <div class="breakdown-item">
                            <span class="breakdown-label">Compromises (-5 to -15 each):</span>
                            <span id="compromiseDeductions" class="breakdown-value">-0</span>
            </div>
                        <div class="breakdown-item">
                            <span class="breakdown-label">Harmonic Progression:</span>
                            <span id="harmonicScore" class="breakdown-value">+0</span>
        </div>
                    </div>
                    <div class="score-criteria">
                        <h5>Scoring Criteria:</h5>
                        <div class="criteria-grid">
                            <div class="criteria-section">
                                <strong>Errors (-20 points each):</strong>
                                <ul>
                                    <li>Parallel fifths/octaves/unisons</li>
                                    <li>Voice crossing</li>
                                    <li>Voice range violations</li>
                                    <li>Incomplete chords (missing 3rd/5th)</li>
                                    <li>Large melodic leaps (>octave)</li>
                                </ul>
                            </div>
                            <div class="criteria-section">
                                <strong>Warnings (-5 points each):</strong>
                                <ul>
                                    <li>Wide voice spacing (>octave)</li>
                                    <li>Unresolved tendency tones</li>
                                    <li>Doubled leading tones</li>
                                    <li>Poor chord spacing</li>
                                    <li>Moderate melodic leaps</li>
                                </ul>
                            </div>
                            <div class="criteria-section">
                                <strong>Compromises (-5 to -15 each):</strong>
                                <ul>
                                    <li>Forced parallel motion (-15)</li>
                                    <li>High algorithm cost (-15)</li>
                                    <li>Moderate voice leading issues (-10)</li>
                                    <li>Minor spacing compromises (-5)</li>
                                    <li>Bass line constraints (-5 to -15)</li>
                                </ul>
                            </div>
                            <div class="criteria-section">
                                <strong>Quality Bonuses:</strong>
                                <ul>
                                    <li>Smooth voice leading (+1-3)</li>
                                    <li>Proper doubling (+1-2)</li>
                                    <li>Good chord progressions (+1-5)</li>
                                    <li>Effective cadences (+2-5)</li>
                                    <li>Contrary motion (+1-2)</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="validation-content">
                <div class="errors-section" id="errorsSection" style="display: none;">
                    <h4>‚ùå Errors Found:</h4>
                    <ul id="errorsList"></ul>
                </div>
                <div class="warnings-section" id="warningsSection" style="display: none;">
                    <h4>‚ö†Ô∏è Warnings:</h4>
                    <ul id="warningsList"></ul>
                </div>
                <div class="suggestions-section">
                    <h4>üí° Suggestions:</h4>
                    <ul id="suggestionsList"></ul>
                </div>
                <div class="compromises-section" id="compromisesSection" style="display: none;">
                    <h4>‚öñÔ∏è Algorithm Compromises:</h4>
                    <div class="compromise-explanation">
                        <p>Sometimes the algorithm must violate ideal SATB rules to accommodate your bass line and chord choices. These compromises explain why certain violations were necessary:</p>
                    </div>
                    <ul id="compromisesList"></ul>
                </div>
        </div>
    </div>

    <script src="config.js"></script>
    <script defer src="audio-player.js"></script>
    <script defer src="tutorial.js"></script>
    <script defer src="enhanced-notation.js"></script>
    <script defer src="export-utilities.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            initializeVexflow();
        });

        let bassLine = [];
        let currentKey = 'C major';  // Updated to match backend format
        let currentProgression = null;
        let satbHarmonization = null;
        let currentProgressionSuggestions = [];
        
        const VOICE_RANGES = {
            soprano: { min: 60, max: 84 },  // C4 to C6
            alto: { min: 55, max: 76 },     // G3 to E5
            tenor: { min: 48, max: 69 },    // C3 to A4
            bass: { min: 38, max: 64 }      // D2 to E4
        };
        
        const noteToMidi = {
            'C': 60, 'C#': 61, 'Db': 61, 'D': 62, 'D#': 63, 'Eb': 63, 'E': 64, 'F': 65,
            'F#': 66, 'Gb': 66, 'G': 67, 'G#': 68, 'Ab': 68, 'A': 69, 'A#': 70, 'Bb': 70, 'B': 71
        };

        const midiToNoteNameSimple = {
            0: 'C', 1: 'C#', 2: 'D', 3: 'D#', 4: 'E', 5: 'F', 
            6: 'F#', 7: 'G', 8: 'G#', 9: 'A', 10: 'A#', 11: 'B'
        };

        const chordDatabase = {
            'I': { function: 'Tonic', chordTones: { root: 'C', third: 'E', fifth: 'G' }, type: 'major' },
            'ii': { function: 'Subdominant', chordTones: { root: 'D', third: 'F', fifth: 'A' }, type: 'minor' },
            'iii': { function: 'Tonic', chordTones: { root: 'E', third: 'G', fifth: 'B' }, type: 'minor' },
            'IV': { function: 'Subdominant', chordTones: { root: 'F', third: 'A', fifth: 'C' }, type: 'major' },
            'V': { function: 'Dominant', chordTones: { root: 'G', third: 'B', fifth: 'D' }, type: 'major' },
            'V7': { function: 'Dominant', chordTones: { root: 'G', third: 'B', fifth: 'D', seventh: 'F' }, type: 'dominant-seventh' },
            'vi': { function: 'Tonic', chordTones: { root: 'A', third: 'C', fifth: 'E' }, type: 'minor' },
            'vii¬∞': { function: 'Dominant', chordTones: { root: 'B', third: 'D', fifth: 'F' }, type: 'diminished' },
            'I6': { function: 'Tonic', chordTones: { root: 'C', third: 'E', fifth: 'G' }, type: 'major', inversion: 1 },
            'V6': { function: 'Dominant', chordTones: { root: 'G', third: 'B', fifth: 'D' }, type: 'major', inversion: 1 },
            'vii¬∞6': { function: 'Dominant', chordTones: { root: 'B', third: 'D', fifth: 'F' }, type: 'diminished', inversion: 1 },
            'I64': { function: 'Tonic', chordTones: { root: 'C', third: 'E', fifth: 'G' }, type: 'major', inversion: 2 },
        };
        
        const bassNoteToRomanNumerals = {
            'C': ['I', 'vi', 'IV'],
            'D': ['ii', 'V', 'vii¬∞', 'V7'],
            'E': ['I', 'iii', 'vi'],
            'F': ['IV', 'ii', 'V7'],
            'G': ['V', 'I', 'iii', 'V7'],
            'A': ['vi', 'IV', 'ii'],
            'B': ['V', 'vii¬∞', 'iii', 'V7']
        };

        function getNoteName(noteString) {
            if (!noteString || typeof noteString !== 'string') return 'C';
            return noteString.replace(/[0-9#b]/g, '');
        }

        function initializeVexflow() {
            try {
                const { Renderer, Stave } = Vex.Flow;
                const bassStaffDiv = document.getElementById('bassStaff');
                const renderer = new Renderer(bassStaffDiv, Renderer.Backends.SVG);
                renderer.resize(500, 150);
                const context = renderer.getContext();
                const stave = new Stave(10, 40, 480);
                stave.addClef("bass").addTimeSignature("4/4");
                stave.setContext(context).draw();
            } catch (e) {
                console.error("VexFlow initialization failed:", e);
            }
        }
        
        function addBassNote() {
            const input = document.getElementById('bassNoteInput');
            let note = input.value.trim();
            if (note) {
                // If no octave is specified, default to octave 3 to prevent VexFlow crash.
                if (!/\d/.test(note)) {
                    note = note + '3';
                }
                bassLine.push(note);
                input.value = '';
                input.focus();
                drawBassLine();
            }
        }

        function deleteLastNote() {
            if (bassLine.length > 0) {
                bassLine.pop();
                drawBassLine();
            }
        }

        function clearBassLine() {
            bassLine = [];
            drawBassLine();
            document.getElementById('progressionSuggestions').style.display = 'none';
            document.getElementById('satbOutput').style.display = 'none';
            document.getElementById('validationResults').style.display = 'none';
            document.getElementById('compromisesSection').style.display = 'none';
            document.getElementById('scoreBreakdownBtn').style.display = 'none';
            document.getElementById('scoreBreakdown').style.display = 'none';
        }
        
        function updateKeyDisplay() {
            const keySelect = document.getElementById('keySelect');
            const selectedKey = keySelect.value;
            currentKey = selectedKey;
            
            // Update the display
            const keyInfo = document.getElementById('keyInfo');
            keyInfo.textContent = `Currently in: ${selectedKey.charAt(0).toUpperCase() + selectedKey.slice(1)}`;
            
            // Clear any existing progressions since they're no longer valid for the new key
            document.getElementById('progressionSuggestions').style.display = 'none';
            document.getElementById('satbOutput').style.display = 'none';
            document.getElementById('validationResults').style.display = 'none';
            document.getElementById('compromisesSection').style.display = 'none';
            document.getElementById('scoreBreakdownBtn').style.display = 'none';
            document.getElementById('scoreBreakdown').style.display = 'none';
            currentProgression = null;
            satbHarmonization = null;
            currentProgressionSuggestions = [];
        }

        function drawBassLine() {
            const { Renderer, Stave, StaveNote, Formatter, Voice, Accidental, Barline } = Vex.Flow;
            const staffDiv = document.getElementById('bassStaff');
            staffDiv.innerHTML = ''; 

            if (bassLine.length === 0) {
                initializeVexflow();
                return;
            }

            const notesPerMeasure = 4;
            const measuresPerLine = 4;
            const numNotes = bassLine.length;
            const numMeasures = Math.ceil(numNotes / notesPerMeasure);
            const numLines = Math.ceil(numMeasures / measuresPerLine);

            const measureWidth = 120;
            const clefWidth = 60;
            const systemHeight = 130;

            const totalWidth = clefWidth + (Math.min(numMeasures, measuresPerLine) * measureWidth) + 40;
            const totalHeight = (systemHeight * numLines);

            const renderer = new Renderer(staffDiv, Renderer.Backends.SVG);
            renderer.resize(totalWidth, totalHeight);
            const context = renderer.getContext();
            context.clear();

            let currentX = 10;
            let currentY = 0;

            for (let i = 0; i < numMeasures; i++) {
                const measureOnLine = i % measuresPerLine;
                if (i > 0 && measureOnLine === 0) { // New line
                    currentX = 10;
                    currentY += systemHeight;
                }

                const isFirstMeasureOnLine = (measureOnLine === 0);
                const staveWidth = isFirstMeasureOnLine ? measureWidth + clefWidth : measureWidth;
                
                const stave = new Stave(currentX, currentY, staveWidth);

                if (isFirstMeasureOnLine) {
                    stave.addClef("bass").addTimeSignature("4/4");
                }

                const isLastMeasure = (i === numMeasures - 1);
                stave.setEndBarType(isLastMeasure ? Barline.type.END : Barline.type.SINGLE);
                stave.setContext(context).draw();

                const noteStart = i * notesPerMeasure;
                const noteEnd = Math.min(noteStart + notesPerMeasure, numNotes);
                const notesForMeasure = bassLine.slice(noteStart, noteEnd);

                if (notesForMeasure.length > 0) {
                    const vexNotes = notesForMeasure.map(noteStr => {
                        const note = new StaveNote({
                            keys: [noteStr.replace(/(\d)/, '/$1')],
                            duration: "q",
                            clef: "bass"
                        });
                        if (noteStr.includes('#')) note.addModifier(new Accidental("#"));
                        if (noteStr.includes('b')) note.addModifier(new Accidental("b"));
                        return note;
                    });
                    
                    const voice = new Voice({ num_beats: vexNotes.length, beat_value: 4 }).addTickables(vexNotes);
                    new Formatter().joinVoices([voice]).format([voice], measureWidth - 10);
                    voice.draw(context, stave);
                }
                
                currentX += staveWidth;
            }
        }
        
        function analyzeBassLine() {
            const notesToAnalyze = bassLine; // Analyze the entire bass line
            if (notesToAnalyze.length === 0) {
                alert("Please add at least one bass note.");
                return;
            }
            
            document.getElementById('loadingIndicator').style.display = 'block';

            // Call the backend API
            fetch(getBackendUrl() + '/analyze_bassline', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    bass_notes: notesToAnalyze,
                    key: currentKey  // Send the selected key
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert('Error: ' + data.error);
                return;
            }
            
                // Convert backend response to frontend format
                const suggestions = convertBackendResponse(data);
                displayProgressionSuggestions(suggestions);
                document.getElementById('loadingIndicator').style.display = 'none';
            })
            .catch(error => {
                console.error('Error calling backend:', error);
                alert('Error connecting to backend. Make sure your Flask server is running.');
                document.getElementById('loadingIndicator').style.display = 'none';
            });
        }

        function convertBackendResponse(data) {
            // Convert the new backend response format to frontend format
            const suggestions = [];
            const key = data.key;
            
            // The backend now returns scored progressions with detailed information
            data.progressions.forEach(progression => {
                suggestions.push({
                    romanNumerals: progression.roman_numerals,
                    score: progression.score,
                    key: key,
                    style: progression.style,
                    description: progression.description
                });
            });
            
            return suggestions;
        }

        function displayProgressionSuggestions(progressions) {
            const suggestionsDiv = document.getElementById('progressionSuggestions');
            const listDiv = document.getElementById('suggestionsList');
            
            currentProgressionSuggestions = progressions;
            
            let html = '';
            progressions.forEach((prog, index) => {
                const qualityText = prog.score >= 120 ? 'Excellent' : 
                                   prog.score >= 100 ? 'Very Good' :
                                   prog.score >= 80 ? 'Good' : 'Fair';
                
                html += `
                    <div class="suggestion-item" onclick="selectProgression(${index})">
                        <div class="progression-title">
                            Option ${index + 1}: ${qualityText} (Score: ${Math.round(prog.score)})
                        </div>
                        <div class="progression-style">${prog.style || 'Classical'}</div>
                        <div class="roman-numerals">${prog.romanNumerals.join(' - ')}</div>
                        <div class="progression-description">${prog.description || ''}</div>
                    </div>
                `;
            });
            
            listDiv.innerHTML = html;
            suggestionsDiv.style.display = 'block';
            
            // Show the scoring guide
            const scoringGuide = document.getElementById('scoringGuide');
            scoringGuide.style.display = 'block';
        }

        function selectProgression(index) {
            document.querySelectorAll('.suggestion-item').forEach(item => item.classList.remove('selected'));
            document.querySelectorAll('.suggestion-item')[index].classList.add('selected');
            
            currentProgression = currentProgressionSuggestions[index];
            generateSATBHarmonization();
        }

        function generateSATBHarmonization() {
            if (!currentProgression) return;
            
            // Call backend to generate SATB harmonization
            const basslengths = bassLine.slice(0, currentProgression.romanNumerals.length);
            
            fetch(getBackendUrl() + '/realize_satb', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    chord_progression: currentProgression.romanNumerals,
                    bass_notes: basslengths,
                    key: currentKey
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    console.error('SATB Error:', data.error);
                    alert('Error generating SATB: ' + data.error);
                return;
            }
            
                // Convert backend format to frontend format
                satbHarmonization = convertSATBResponse(data.satb_harmonization);
                displaySATBHarmonization(satbHarmonization);
                
                // Display validation results
                if (data.validation) {
                    displayValidationResults(data.validation);
                }
            })
            .catch(error => {
                console.error('Error calling SATB backend:', error);
                alert('Error connecting to backend for SATB generation.');
            });
        }
        
        function convertSATBResponse(backendSATB) {
            // Convert backend SATB format to frontend format
                return {
                soprano: backendSATB.map(chord => chord.soprano),
                alto: backendSATB.map(chord => chord.alto),
                tenor: backendSATB.map(chord => chord.tenor),
                bass: backendSATB.map(chord => chord.bass)
            };
        }
        
        function displayValidationResults(validation) {
            const validationDiv = document.getElementById('validationResults');
            const scoreSpan = document.getElementById('validationScore');
            const errorsSection = document.getElementById('errorsSection');
            const warningsSection = document.getElementById('warningsSection');
            const compromisesSection = document.getElementById('compromisesSection');
            const errorsList = document.getElementById('errorsList');
            const warningsList = document.getElementById('warningsList');
            const suggestionsList = document.getElementById('suggestionsList');
            const compromisesList = document.getElementById('compromisesList');
            
            // Show the validation section
            validationDiv.style.display = 'block';
            
            // Update score with color coding
            scoreSpan.textContent = validation.score;
            if (validation.score >= 80) {
                scoreSpan.style.color = '#27ae60'; // Green
            } else if (validation.score >= 60) {
                scoreSpan.style.color = '#f39c12'; // Orange
            } else {
                scoreSpan.style.color = '#e74c3c'; // Red
            }
            
            // Show score breakdown button and update breakdown details
            const scoreBreakdownBtn = document.getElementById('scoreBreakdownBtn');
            scoreBreakdownBtn.style.display = 'block';
            updateScoreBreakdown(validation);
            
            // Clear previous results
            errorsList.innerHTML = '';
            warningsList.innerHTML = '';
            suggestionsList.innerHTML = '';
            compromisesList.innerHTML = '';
            
            // Display errors
            const errors = validation.errors.filter(e => e.severity === 'error');
            if (errors.length > 0) {
                errorsSection.style.display = 'block';
                errors.forEach(error => {
                    const li = document.createElement('li');
                    li.className = 'validation-item error-item';
                    li.innerHTML = `
                        <div class="validation-item-header">${error.description}</div>
                        <div class="validation-item-location">${error.location} - ${error.voice || ''}</div>
                    `;
                    errorsList.appendChild(li);
                });
            } else {
                errorsSection.style.display = 'none';
            }
            
            // Display warnings  
            const warnings = validation.errors.filter(e => e.severity === 'warning');
            if (warnings.length > 0) {
                warningsSection.style.display = 'block';
                warnings.forEach(warning => {
                    const li = document.createElement('li');
                    li.className = 'validation-item warning-item';
                    li.innerHTML = `
                        <div class="validation-item-header">${warning.description}</div>
                        <div class="validation-item-location">${warning.location} - ${warning.voice || ''}</div>
                    `;
                    warningsList.appendChild(li);
                });
            } else {
                warningsSection.style.display = 'none';
            }
            
            // Display suggestions
            if (validation.suggestions && validation.suggestions.length > 0) {
                validation.suggestions.forEach(suggestion => {
                    const li = document.createElement('li');
                    li.className = 'validation-item suggestion-item';
                    li.innerHTML = `<div class="validation-item-header">${suggestion}</div>`;
                    suggestionsList.appendChild(li);
                });
            }
            
            // Display algorithm compromises
            if (validation.compromises && validation.compromises.length > 0) {
                compromisesSection.style.display = 'block';
                validation.compromises.forEach(compromise => {
                    const li = document.createElement('li');
                    li.className = 'validation-item compromise-item';
                    li.innerHTML = `
                        <div class="validation-item-header">${compromise.description}</div>
                        <div class="validation-item-location">${compromise.location || ''}</div>
                        <div style="margin-top: 8px; font-style: italic; color: #7f8c8d;">${compromise.explanation}</div>
                    `;
                    compromisesList.appendChild(li);
                });
                         } else {
                 compromisesSection.style.display = 'none';
             }
         }
         
         function toggleScoreBreakdown() {
             const breakdown = document.getElementById('scoreBreakdown');
             const button = document.getElementById('scoreBreakdownBtn');
             
             if (breakdown.style.display === 'none') {
                 breakdown.style.display = 'block';
                 button.textContent = 'üìä Hide Score Breakdown';
             } else {
                 breakdown.style.display = 'none';
                 button.textContent = 'üìä Show Score Breakdown';
             }
         }
         
         function updateScoreBreakdown(validation) {
             // Calculate score breakdown
             const errors = validation.errors.filter(e => e.severity === 'error');
             const warnings = validation.errors.filter(e => e.severity === 'warning');
             const compromises = validation.compromises || [];
             
             const baseScore = 100;
             const errorDeduction = errors.length * 20;
             const warningDeduction = warnings.length * 5;
             
             // Calculate compromise penalty
             let compromiseDeduction = 0;
             compromises.forEach(compromise => {
                 if (compromise.severity === 'high') {
                     compromiseDeduction += 15;
                 } else if (compromise.severity === 'medium') {
                     compromiseDeduction += 10;
                 } else {
                     compromiseDeduction += 5;
                 }
             });
             
             const voiceLeadingBonus = calculateVoiceLeadingBonus(validation);
             const harmonicBonus = calculateHarmonicBonus(validation);
             
             // Update breakdown display
             document.getElementById('baseScore').textContent = baseScore;
             
             const errorSpan = document.getElementById('errorDeductions');
             errorSpan.textContent = errorDeduction > 0 ? `-${errorDeduction}` : '0';
             errorSpan.className = errorDeduction > 0 ? 'breakdown-value negative' : 'breakdown-value';
             
             const warningSpan = document.getElementById('warningDeductions');
             warningSpan.textContent = warningDeduction > 0 ? `-${warningDeduction}` : '0';
             warningSpan.className = warningDeduction > 0 ? 'breakdown-value negative' : 'breakdown-value';
             
             const compromiseSpan = document.getElementById('compromiseDeductions');
             compromiseSpan.textContent = compromiseDeduction > 0 ? `-${compromiseDeduction}` : '0';
             compromiseSpan.className = compromiseDeduction > 0 ? 'breakdown-value negative' : 'breakdown-value';
             
             document.getElementById('voiceLeadingScore').textContent = voiceLeadingBonus > 0 ? `+${voiceLeadingBonus}` : '0';
             document.getElementById('harmonicScore').textContent = harmonicBonus > 0 ? `+${harmonicBonus}` : '0';
         }
         
         function calculateVoiceLeadingBonus(validation) {
             // Award bonus points for good voice leading
             let bonus = 0;
             
             // No errors = good voice leading
             const errors = validation.errors.filter(e => e.severity === 'error');
             if (errors.length === 0) {
                 bonus += 3; // Perfect voice leading bonus
             }
             
             // Few warnings = smooth voice leading
             const warnings = validation.errors.filter(e => e.severity === 'warning');
             if (warnings.length <= 1) {
                 bonus += 2; // Smooth voice leading bonus
             }
             
             return Math.min(bonus, 5); // Cap at +5
         }
         
         function calculateHarmonicBonus(validation) {
             // Award bonus for good harmonic progressions
             let bonus = 0;
             
             // If score is high overall, award harmonic bonus
             if (validation.score >= 90) {
                 bonus += 3; // Excellent harmonic progression
             } else if (validation.score >= 80) {
                 bonus += 2; // Good harmonic progression
             } else if (validation.score >= 70) {
                 bonus += 1; // Decent harmonic progression
             }
             
             return Math.min(bonus, 5); // Cap at +5
         }
         
         async function playCurrentSATB() {
            if (!satbHarmonization) {
                alert('No SATB harmonization available to play!');
                return;
            }
            
            // Initialize audio player if not already done
            if (!window.satbAudioPlayer.isInitialized) {
                await window.satbAudioPlayer.initialize();
            }
            
            // Create rhythm array (all quarter notes for now)
            const rhythm = new Array(satbHarmonization.soprano.length).fill('q');
            
            // Play the progression
            window.satbAudioPlayer.playProgression(satbHarmonization, rhythm);
            
            // Update button text to show it's playing
            document.getElementById('playBtn').innerHTML = '‚è∏ Playing...';
            document.getElementById('playBtn').disabled = true;
            
            // Re-enable button after estimated duration
            const duration = (60 / window.satbAudioPlayer.tempo) * rhythm.length * 1000;
            setTimeout(() => {
                document.getElementById('playBtn').innerHTML = '‚ñ∂ Play SATB';
                document.getElementById('playBtn').disabled = false;
            }, duration + 500);
        }
        
        function stopCurrentSATB() {
            if (window.satbAudioPlayer) {
                window.satbAudioPlayer.stop();
                document.getElementById('playBtn').innerHTML = '‚ñ∂ Play SATB';
                document.getElementById('playBtn').disabled = false;
            }
        }
        
        function updateTempo(value) {
            document.getElementById('tempoValue').textContent = value;
            if (window.satbAudioPlayer) {
                window.satbAudioPlayer.setTempo(value);
            }
        }
        
        function displaySATBHarmonization(voices) {
            const { Renderer, Stave, StaveNote, Formatter, Voice, Accidental, StaveConnector, Barline } = Vex.Flow;
            const staffDiv = document.getElementById('satbStaff');
            staffDiv.innerHTML = '';
            document.getElementById('satbOutput').style.display = 'block';

            if (voices.soprano.length === 0) return;

            const renderer = new Renderer(staffDiv, Renderer.Backends.SVG);
            
            const notesPerMeasure = 4;
            const numMeasures = Math.ceil(voices.soprano.length / notesPerMeasure);
            const measuresPerLine = Math.min(2, numMeasures); // Fewer measures per line to prevent overlap
            const numLines = Math.ceil(numMeasures / measuresPerLine);
            
            const measureWidth = 350; // Much wider measures to prevent bar line overlap
            const clefWidth = 120;    // More space for clefs and signatures  
            const systemHeight = 300; // Taller for better readability
            const rightMargin = 100;  // Extra margin on the right
            
            // Calculate width to fit all measures on each line
            const totalWidth = clefWidth + (measuresPerLine * measureWidth) + rightMargin;
            const totalHeight = (systemHeight * numLines) + 40; // Extra bottom margin

            renderer.resize(totalWidth, totalHeight);
            const context = renderer.getContext();
            context.clear();

            function createVexNote(noteData, clef) {
                const noteName = noteData.replace(/(\d)/, '/$1');
                const keys = [noteName];
                const vexNote = new StaveNote({ clef, keys, duration: "q" });
                if (noteName.includes('#')) {
                    vexNote.addModifier(new Accidental("#"));
                } else if (noteName.includes('b')) {
                    vexNote.addModifier(new Accidental("b"));
                }
                return vexNote;
            }

            let currentY = 40;

            for (let line = 0; line < numLines; line++) {
                let currentX = 40; // More left margin so symbols don't get cut off
                const measuresOnThisLine = Math.min(measuresPerLine, numMeasures - (line * measuresPerLine));

                for (let i = 0; i < measuresOnThisLine; i++) {
                    const measureIndex = (line * measuresPerLine) + i;
                    const isFirstMeasureOnLine = (i === 0);
                    const staveWidth = measureWidth; // Consistent width for all measures

                    const trebleStave = new Stave(currentX, currentY, staveWidth);
                    const bassStave = new Stave(currentX, currentY + 100, staveWidth);

                    if (isFirstMeasureOnLine) {
                        trebleStave.addClef('treble').addTimeSignature('4/4');
                        bassStave.addClef('bass').addTimeSignature('4/4');
                        new StaveConnector(trebleStave, bassStave).setType(StaveConnector.type.BRACE).setContext(context).draw();
                        new StaveConnector(trebleStave, bassStave).setType(StaveConnector.type.SINGLE_LEFT).setContext(context).draw();
                    }
                    
                    const isLastMeasureInPiece = (measureIndex === numMeasures - 1);
                    const barlineType = isLastMeasureInPiece ? Barline.type.END : Barline.type.SINGLE;
                    trebleStave.setEndBarType(barlineType);
                    bassStave.setEndBarType(barlineType);

                    trebleStave.setContext(context).draw();
                    bassStave.setContext(context).draw();

                    const noteStart = measureIndex * notesPerMeasure;
                    const noteEnd = Math.min(noteStart + notesPerMeasure, voices.soprano.length);
                    
                    if (noteEnd > noteStart) {
                        const sopranoMeasure = voices.soprano.slice(noteStart, noteEnd).map(n => {
                            const note = createVexNote(n, 'treble');
                            note.setStemDirection(1); // Stems up
                            return note;
                        });
                        const altoMeasure = voices.alto.slice(noteStart, noteEnd).map(n => {
                            const note = createVexNote(n, 'treble');
                            note.setStemDirection(-1); // Stems down
                            return note;
                        });
                        const tenorMeasure = voices.tenor.slice(noteStart, noteEnd).map(n => {
                            const note = createVexNote(n, 'bass');
                            note.setStemDirection(1); // Stems up
                            return note;
                        });
                        const bassMeasure = voices.bass.slice(noteStart, noteEnd).map(n => {
                            const note = createVexNote(n, 'bass');
                            note.setStemDirection(-1); // Stems down
                            return note;
                        });

                        const beatsInMeasure = sopranoMeasure.length;
                        if (beatsInMeasure > 0) {
                            // Set proper voice modes to prevent overlap
                            const allVoices = [
                                new Voice({ num_beats: beatsInMeasure, beat_value: 4 }).setMode(Voice.Mode.SOFT).addTickables(sopranoMeasure),
                                new Voice({ num_beats: beatsInMeasure, beat_value: 4 }).setMode(Voice.Mode.SOFT).addTickables(altoMeasure),
                                new Voice({ num_beats: beatsInMeasure, beat_value: 4 }).setMode(Voice.Mode.SOFT).addTickables(tenorMeasure),
                                new Voice({ num_beats: beatsInMeasure, beat_value: 4 }).setMode(Voice.Mode.SOFT).addTickables(bassMeasure)
                            ];
                            
                            // Use maximum spacing to prevent overlap with bar lines
                            const formattingWidth = measureWidth - 80; // Leave space for bar lines but not too much
                            const formatter = new Formatter();
                            formatter.joinVoices(allVoices);
                            formatter.format(allVoices, formattingWidth);
                            
                            // Draw voices with proper stem directions
                            allVoices[0].draw(context, trebleStave); // Soprano - stems up
                            allVoices[1].draw(context, trebleStave); // Alto - stems down  
                            allVoices[2].draw(context, bassStave);   // Tenor - stems up
                            allVoices[3].draw(context, bassStave);   // Bass - stems down
                        }
                    }
                    currentX += staveWidth;
                }
                currentY += systemHeight;
            }
        }

        function generateProgressionSuggestions(notesToAnalyze) {
            let allProgressions = [];
            
        function generateCombinations(bassNotes, currentProgression = [], allCombinations = []) {
            if (currentProgression.length === bassNotes.length) {
                allCombinations.push([...currentProgression]);
                return;
            }
            
            const currentBassNote = getNoteName(bassNotes[currentProgression.length]);
            const possibleRomanNumerals = bassNoteToRomanNumerals[currentBassNote] || ['I'];
            
            for (const roman of possibleRomanNumerals) {
                currentProgression.push(roman);
                generateCombinations(bassNotes, currentProgression, allCombinations);
                currentProgression.pop();
            }
        }
            
            generateCombinations(notesToAnalyze, [], allProgressions);
            
            const scoredProgressions = allProgressions.map(progression => {
                const score = scoreProgression(progression);
                return {
                    romanNumerals: progression,
                    score: score,
                };
            });
            
            return scoredProgressions
                .sort((a, b) => b.score - a.score)
                .slice(0, 5);
        }
        
        function scoreProgression(progression) {
            let score = 50;

            const testResult = generateProperSATB(bassLine.slice(0, progression.length), progression);
            
            if (!testResult.isValid) {
                return -1;
            }

            const midiChords = [];
            if (testResult.midiVoices) {
                for (let i = 0; i < testResult.midiVoices.soprano.length; i++) {
                    midiChords.push({
                        soprano: testResult.midiVoices.soprano[i],
                        alto: testResult.midiVoices.alto[i],
                        tenor: testResult.midiVoices.tenor[i],
                        bass: testResult.midiVoices.bass[i]
                    });
                }
            }
            
            const keyInfo = getScale(currentKey, 'major');
            const leadingTone = (keyInfo.root + 11) % 12;

            for (const chord of midiChords) {
                let leadingToneCount = 0;
                for (const voice in chord) {
                    if (chord[voice] % 12 === leadingTone) {
                        leadingToneCount++;
                    }
                }
                if (leadingToneCount > 1) {
                score -= 5;
                }
            }
            
            for (let i = 0; i < midiChords.length - 1; i++) {
                const chord1 = midiChords[i];
                const chord2 = midiChords[i+1];
                
                const sopranoMotion = chord2.soprano - chord1.soprano;
                const bassMotion = chord2.bass - chord1.bass;
                if (sopranoMotion * bassMotion < 0) {
                    score += 2;
                }

                const altoMotion = Math.abs(chord2.alto - chord1.alto);
                const tenorMotion = Math.abs(chord2.tenor - chord1.tenor);
                if (altoMotion > 0 && altoMotion <= 2) { score += 1; }
                if (tenorMotion > 0 && tenorMotion <= 2) { score += 1; }
            }
            
            for (let i = 0; i < progression.length; i++) {
                const h = progression[i];
                const next_h = (i + 1 < progression.length) ? progression[i+1] : null;

                if (h.includes('64')) {
                    const isCadential = h.toUpperCase().includes('I') && next_h && next_h.toUpperCase().includes('V');
                    if (!isCadential) {
                        score -= 4;
                    }
                } else if (h.includes('vii¬∞6')) {
                    const resolvesToTonic = next_h && next_h.toUpperCase().startsWith('I') && !next_h.includes('6');
                    if (resolvesToTonic) {
                        score += 2;
                    } else {
                        score -= 3;
                    }
                } else if (h.includes('vii¬∞')) {
                    score -= 5;
                } else if (h.includes('6')) {
                    score -= 1;
                }
            }

            return score;
        }
        
        function generateProperSATB(bassNotes, romanNumerals) {
            // Dynamic Programming approach based on ekzhang/harmony
            const keyInfo = getScale(currentKey, 'major');
            const leadingTone = (keyInfo.root + 11) % 12;
            
            // Convert bassNotes to MIDI numbers
            const midiBassNotes = bassNotes.map(noteString => {
                const noteName = noteString.replace(/[0-9]/g, '');
                const octave = parseInt(noteString.match(/\d/)?.[0] || '3', 10);
                return noteToMidi[noteName] + (octave - 4) * 12;
            });
            
            // Generate all possible voicings for each chord
            const chordVoicings = [];
            for (let i = 0; i < romanNumerals.length; i++) {
                const roman = romanNumerals[i];
                const chord = chordDatabase[roman];
                if (!chord) continue;
                
                const voicings = generateChordVoicings(chord, leadingTone, midiBassNotes[i]);
                chordVoicings.push(voicings);
            }
            
            if (chordVoicings.length === 0) {
                return { voices: { soprano: [], alto: [], tenor: [], bass: [] }, midiVoices: null, errors: ['No valid chords found'], isValid: false };
            }
            
            // Dynamic Programming to find optimal progression
            const dp = new Array(chordVoicings.length).fill(null).map(() => new Map());
            const prev = new Array(chordVoicings.length).fill(null).map(() => new Map());
            
            // Initialize first chord
            for (const voicing of chordVoicings[0]) {
                const cost = calculateChordCost(voicing, leadingTone);
                dp[0].set(JSON.stringify(voicing), cost);
                prev[0].set(JSON.stringify(voicing), null);
            }
            
            // Fill DP table
            for (let i = 1; i < chordVoicings.length; i++) {
                for (const currentVoicing of chordVoicings[i]) {
                    let bestCost = Infinity;
                    let bestPrev = null;
                    
                    for (const prevVoicing of chordVoicings[i-1]) {
                        const prevKey = JSON.stringify(prevVoicing);
                        const prevCost = dp[i-1].get(prevKey);
                        if (prevCost === undefined) continue;
                        
                        const transitionCost = calculateProgressionCost(prevVoicing, currentVoicing, leadingTone);
                        const totalCost = prevCost + transitionCost;
                        
                        if (totalCost < bestCost) {
                            bestCost = totalCost;
                            bestPrev = prevKey;
                        }
                    }
                    
                    if (bestCost < Infinity) {
                        const currentKey = JSON.stringify(currentVoicing);
                        dp[i].set(currentKey, bestCost);
                        prev[i].set(currentKey, bestPrev);
                    }
                }
            }
            
            // Find best path
            let bestVoicing = null;
            let bestCost = Infinity;
            
            for (const [voicingKey, cost] of dp[dp.length - 1]) {
                if (cost < bestCost) {
                    bestCost = cost;
                    bestVoicing = voicingKey;
                }
            }
            
            if (!bestVoicing) {
                // Try to pick any voicing from the last DP layer, even if not valid
                const lastLayer = Array.from(dp[dp.length - 1].keys());
                if (lastLayer.length > 0) {
                    bestVoicing = lastLayer[0];
                } else {
                    return { voices: { soprano: [], alto: [], tenor: [], bass: [] }, midiVoices: null, errors: ['No valid progression found'], isValid: false };
                }
            }
            
            // Reconstruct path
            const optimalVoicings = [];
            let currentVoicingKey = bestVoicing;
            
            for (let i = dp.length - 1; i >= 0; i--) {
                optimalVoicings.unshift(JSON.parse(currentVoicingKey));
                currentVoicingKey = prev[i].get(currentVoicingKey);
            }
            
            // Convert to voice arrays
            const voices = { soprano: [], alto: [], tenor: [], bass: [] };
            const midiVoices = { soprano: [], alto: [], tenor: [], bass: [] };
            
            for (let i = 0; i < optimalVoicings.length; i++) {
                const voicing = optimalVoicings[i];
                voices.soprano.push(midiToNoteName(voicing.soprano));
                voices.alto.push(midiToNoteName(voicing.alto));
                voices.tenor.push(midiToNoteName(voicing.tenor));
                voices.bass.push(midiToNoteName(voicing.bass));
                
                midiVoices.soprano.push(voicing.soprano);
                midiVoices.alto.push(voicing.alto);
                midiVoices.tenor.push(voicing.tenor);
                midiVoices.bass.push(voicing.bass);
            }
            
            // Check for voice leading errors
            const errors = [];
            for (let i = 1; i < optimalVoicings.length; i++) {
                const vErrors = checkVoiceLeading(
                    optimalVoicings[i-1],
                    optimalVoicings[i],
                    romanNumerals[i-1], 
                    romanNumerals[i], 
                    i
                );
                if (vErrors.length > 0) {
                    errors.push(...vErrors);
                }
            }
            
            return { 
                voices, 
                midiVoices, 
                errors, 
                isValid: errors.length === 0 
            };
        }
        
        function generateChordVoicings(chord, leadingTone, bassMidi) {
            const voicings = [];
            const chordTones = Object.values(chord.chordTones);
            const rootPC = noteToMidi[chordTones[0]] % 12;
            const thirdPC = noteToMidi[chordTones[1]] % 12;
            const fifthPC = noteToMidi[chordTones[2]] % 12;
            
            // Determine doublings based on chord type and leading tone
            const doublings = [];
            
            if (rootPC !== leadingTone) doublings.push(rootPC);
            if (thirdPC !== leadingTone) doublings.push(thirdPC);
            if (fifthPC !== leadingTone) doublings.push(fifthPC);
            
            // Generate all possible voicing combinations
            const notePool = [...chordTones, ...doublings];
            
            // Generate all permutations of 3 notes for upper voices
            const upperPermutations = [];
            for (let i = 0; i < notePool.length; i++) {
                for (let j = 0; j < notePool.length; j++) {
                    for (let k = 0; k < notePool.length; k++) {
                        if (i !== j && i !== k && j !== k) {
                            upperPermutations.push([notePool[i], notePool[j], notePool[k]]);
                        }
                    }
                }
            }
            
            // Generate voicings for each permutation
            for (const upperNotes of upperPermutations) {
                const sopranoCandidates = getNotesInRange(upperNotes[0], VOICE_RANGES.soprano);
                const altoCandidates = getNotesInRange(upperNotes[1], VOICE_RANGES.alto);
                const tenorCandidates = getNotesInRange(upperNotes[2], VOICE_RANGES.tenor);
                
                for (const soprano of sopranoCandidates) {
                    for (const alto of altoCandidates) {
                        // Check alto range relative to soprano
                        if (alto >= soprano || alto < soprano - 12) continue;
                        
                        for (const tenor of tenorCandidates) {
                            // Check tenor range relative to alto
                            if (tenor >= alto || tenor < alto - 12) continue;
                            
                            // Check bass range relative to tenor
                            if (bassMidi >= tenor || bassMidi < tenor - 12) continue;
                            
                            voicings.push({
                                soprano: soprano,
                                alto: alto,
                                tenor: tenor,
                                bass: bassMidi
                            });
                        }
                    }
                }
            }
            
            return voicings;
        }
        
        function getNotesInRange(noteName, range) {
            const notes = [];
            const baseMidi = noteToMidi[noteName];
            
            for (let octave = 0; octave < 8; octave++) {
                const midi = baseMidi + octave * 12;
                if (midi >= range.min && midi <= range.max) {
                    notes.push(midi);
                }
            }
            
            return notes;
        }
        
        function calculateChordCost(voicing, leadingTone) {
            let cost = 0;
            
            // Prefer root position chords to double the root
            const rootPC = voicing.bass % 12;
            const rootCount = [voicing.soprano, voicing.alto, voicing.tenor, voicing.bass]
                .filter(note => note % 12 === rootPC).length;
            
            if (rootCount <= 1) {
                cost += 1;
            }
            
            return cost;
        }
        
        function calculateProgressionCost(chord1, chord2, leadingTone) {
            let cost = 0;
            
            // Voice overlap penalty
            if (chord2.alto > chord1.soprano || chord2.alto < chord1.soprano - 12 ||
                chord2.tenor > chord1.alto || chord2.tenor < chord1.alto - 12 ||
                chord2.bass > chord1.tenor || chord2.bass < chord1.tenor - 12) {
                cost += 40;
            }
            
            // Melodic leap penalties
            const sopranoLeap = Math.abs(chord2.soprano - chord1.soprano);
            const altoLeap = Math.abs(chord2.alto - chord1.alto);
            const tenorLeap = Math.abs(chord2.tenor - chord1.tenor);
            const bassLeap = Math.abs(chord2.bass - chord1.bass);
            
            cost += Math.pow(sopranoLeap, 2) / 50;
            cost += Math.pow(altoLeap, 2) / 3;
            cost += Math.pow(tenorLeap, 2) / 3;
            cost += Math.pow(bassLeap, 2) / 3;
            
            // Parallel intervals
            const voices1 = [chord1.soprano, chord1.alto, chord1.tenor, chord1.bass];
            const voices2 = [chord2.soprano, chord2.alto, chord2.tenor, chord2.bass];
            
            for (let i = 0; i < 4; i++) {
                for (let j = i + 1; j < 4; j++) {
                    const interval1 = (voices1[j] - voices1[i]) % 12;
                    const interval2 = (voices2[j] - voices2[i]) % 12;
                    
                    if (interval1 === interval2) {
                        const motion1 = voices2[i] - voices1[i];
                        const motion2 = voices2[j] - voices1[j];
                        
                        if ((motion1 > 0 && motion2 > 0) || (motion1 < 0 && motion2 < 0)) {
                            if (interval1 === 7) cost += 60; // Parallel fifth
                            if (interval1 === 0) cost += 100; // Parallel octave
                        }
                    }
                }
            }
            
            // Contrary motion bonus for outer voices
            const sopranoMotion = chord2.soprano - chord1.soprano;
            const bassMotion = chord2.bass - chord1.bass;
            if (sopranoMotion * bassMotion < 0) {
                cost -= 2; // Bonus for contrary motion
            }
            
            // Leading tone resolution
            if (chord1.soprano % 12 === leadingTone || chord1.alto % 12 === leadingTone || 
                chord1.tenor % 12 === leadingTone || chord1.bass % 12 === leadingTone) {
                
                const leadingToneVoice = [chord1.soprano, chord1.alto, chord1.tenor, chord1.bass]
                    .findIndex(note => note % 12 === leadingTone);
                
                const resolution = chord2[['soprano', 'alto', 'tenor', 'bass'][leadingToneVoice]] - 
                                 chord1[['soprano', 'alto', 'tenor', 'bass'][leadingToneVoice]];
                
                if (leadingToneVoice === 0 || leadingToneVoice === 3) { // Outer voices
                    if (resolution !== 1) cost += 100;
                } else { // Inner voices
                    if (resolution !== 1 && resolution !== -3 && resolution !== -4) cost += 100;
                }
            }
            
            return cost;
        }

        function getScale(key, mode) {
            const rootName = key.split(' ')[0];
            const root = noteToMidi[rootName];
            const intervals = (mode === 'major') ? [0, 2, 4, 5, 7, 9, 11] : [0, 2, 3, 5, 7, 8, 10];
            const notes = intervals.map(i => root + i);
            return { root, intervals, notes };
        }
        
        function midiToNoteName(midi) {
            const octave = Math.floor(midi / 12) - 1;
            const noteName = midiToNoteNameSimple[midi % 12];
            return `${noteName}${octave}`;
        }

        function getClosestMidiInRange(targetMidi, range) {
            let currentMidi = targetMidi;
            while (currentMidi < range.min) currentMidi += 12;
            while (currentMidi > range.max) currentMidi -= 12;
            if (currentMidi < range.min) currentMidi += 12;
            return currentMidi <= range.max ? currentMidi : -1;
        }
        
        function findBestVoiceMovement(previousNote, availableNotes, range) {
            let bestNote = -1;
            let smallestLeap = Infinity;
            for (const note of availableNotes) {
                let midi = getClosestMidiInRange(note, range);
                if (midi !== -1) {
                    const leap = Math.abs(midi - previousNote);
                    if (leap < smallestLeap) {
                        smallestLeap = leap;
                        bestNote = midi;
                    }
                }
            }
            return bestNote === -1 ? getClosestMidiInRange(availableNotes[0], range) : bestNote;
        }

    </script>
</body>
</html>
